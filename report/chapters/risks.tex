\chapter{What Could Go Wrong?}
	Having described the implementation of the prototype, it is very important to acknowledge any short-comings or dangers in the use of the final solution. As such, in this chapter the greatest risks are discussed.

	\section{Identical Encryption and Decryption Key}
		In section \ref{sec:design:pseudo-zero-knowledge} on page \pageref{sec:design:pseudo-zero-knowledge} it was discussed why the design of the system requires two passwords. However, at \emph{no} point will the implementation ever actually compare these passwords. As such, it is \emph{completely} possible for the user to have identical authentication and decryption passwords.

		The risk of this, is potentially giving the server owner the ability to decrypt the stored passwords, since the authentication password \emph{is} sent to the back-end, for authentication purposes. However, this all depends on the user's \emph{choice}, and as such is not regarded as a critical risk.
	
	\section{Trusting the Server Owner}
		While the pseudo-zero-knowledge concept introduced in section \ref{sec:design:pseudo-zero-knowledge} on page \pageref{sec:design:pseudo-zero-knowledge} is intended to keep admins from reading all of the users' passwords, there is more to the story.

		The admin, whom is assumed to be the owner of the back-end, \emph{could} change the JavaScript files of the front-end, making them send all the unencrypted data back to him. 

		In \emph{theory} this could be mitigated by publishing a checksum of the bundled JavaScript file, that the front-end executes. This could then be compared, using a separate browser plugin on load, determining whether or not the file had been tampered with.

		However, there is a much more fundamental issue here: Trust. This implementation is meant to be \emph{self-hosted}. The multi-user support is intended to allow multiple users from the same small community or home, e.g. husband and wife, to share the same back-end for storing their private passwords. As such, a certain level of \emph{trust} is assumed. The pseudo-zero-knowledge ensures that the admin can not read the passwords, using information found in the implementation as originally developed. Beyond that, the users will simply have to trust the admin, that he or she will not deliberately alter the files, in order to access the passwords.

	\section{Third Party Libraries}
		As previously stated, the implementation relies on third party libraries, to perform certain functions. For instance, the Forge library is used for handling encryption in the front-end, and the Node-Argon2 library, is used for performing Argon2 password hashing in the back-end. 

		Using these libraries -- or dependencies, as they're called in the Node.js community -- enabled prototypes to be rapidly developed. However, they also introduce a risk: The implementation relies on other peoples code. Recently the largest dependency manager for Node.js, npm, experienced a catastrophic event. A very basic package, \verb=left-pad= was removed from npm, due to a legal dispute between the author and a third party\cite{npm_leftpad}. This caused a chain reaction of chaos, as packages that depended on \verb=left-pad= no longer could install, and packages depending on those packages couldn't either -- and so forth. This is unfortunately the risk, when working with these kinds of dependencies, but it isn't even the worst.

		When depending on libraries, the developer\emph{(s)} trust that the author\emph{(s)} of the library is forthright about the content of the library. For instance, the Forge library could, for all intents and purposes, simply send every single encryption payload to a remote server. Luckily, since this \emph{is} the world of open source, major issues like this can be inspected and possibly found. However, there might still be both intentional and unintentional security risks involved with using these libraries. As such, it is needed determine the whether or not any given dependency can be trusted.

	\section{Dumping the Memory}
		Unfortunately, since the implementation is run in a browser, it is not possible to implement features depending on for instance Microsoft's Data Protection Application Programming Interface \emph{(DPAPI)}, like KeePass does. As such, storing the passwords unencrypted is \emph{unfortunately} a security risk.

		There really isn't any way around this risk. For it to be shown to the user, in the browser, it needs to be decrypted. For it to be shown, it needs to be stored. Should an attacker make a dump of the process memory, he or she will \emph{unfortunately} gain access to any passwords decrypted. 

		The same is said about swap partitions and pagefiles. Unfortunately, there is a risk of clear text passwords ending up in these. It is a risk, that comes with the choice of implementation. Should it have been chosen to implement native clients instead, this could possibly be circumvented. So this risk, is the price that will have to be paid, for the convenience of a web application.

		The only redeeming thing to be said about this risk, is the fact that the implementation attempts to remove decrypted passwords again, as soon as possible. When the user changes focus from the password, its variable is overwritten. This is, however, doesn't increase the security all that much. For user experience purposes, the decrypted private key is kept in memory. So even when removing the decrypted passwords, the encryption key for decrypting \emph{all} passwords, still resides \emph{in memory}. One could of course go about clearing this as well, but that would mean the user would have to enter the decryption password \emph{every} time he or she needed to access a password -- which would result in a horrible user experience.

		All in all, this risk is unfortunately unavoidable. It is simply the price paid for the convenience.

	\section{Expiration of the Token}
		In section \ref{sec:design:jwt} on page \pageref{sec:design:jwt} it was decided that the implementation will be using JWT's to handle API authentication. What was \emph{not} discussed, was the security impact this would have.

		When JWT's are used, commonly there is an expiration time set. At the time of this writing, that timer is set to 24 hours, meaning that after 24 hours the user needs to re-authenticate. When those 24 hours have passed, the token is no longer valid and therefore can \emph{not} be used to gain access to the back-end.

		However, that also means that should this token fall into the hands of the attacker, he or she will have access to the user's data for 24 hours. Take note: Since password encryption and decryption happens in the browser, he or she will \emph{not} have direct access to the passwords.

		Obtaining these tokens commonly happen through either Cross-Site Request Forgery \emph{(CSRF)} or Cross-Site Scripting \emph{(XSS)}. While there definitely could be security vulnerabilities not found at this point, it is believed that no such exists. Additionally, it is not possible to intercept the token in transit, due to HTTPS being enforced at \emph{all} times.

		As such, the risk of the token being compromised, is relatively low.




		%Another option is to allow for token revocation. This would entail storing the token in the database, allowing the user to revoke tokens at any point in time.

	\section{Forgetting the Password}
		One of the more unfortunate ``issues'' with the implementation, is the lack of account recovery. The authentication password can, \emph{of course}, be reset. But the decryption password can \emph{not} be reset -- for good reasons. As such, if the user forgets his or her decryption password, \emph{nothing} can be done.

		Should this situation arise, it would be unfortunate. But there is nothing that can be done to remedy this risk, that would not lower the overall security of the system. As such, it is deemed a necessary risk.



